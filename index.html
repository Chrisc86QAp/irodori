<!doctype html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="robots" content="noindex, nofollow">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="format-detection" content="address=no,email=no">
<meta name="skype_toolbar" content="skype_toolbar_parser_compatible">
<style>
html{
	background:#fbfbfb;
	background-image: radial-gradient(#fffc995e 2px, transparent 2px), radial-gradient(#fffc995e 2px, #fff 2px);
	background-size: 50px 50px;
	background-position: 0 0,25px 25px;
}
html,textarea {
	font-size:15px;
	color: #373737;
	letter-spacing: 0.06rem;
}
figcaption,label,legend{
	font-size:1.2rem;
}
h1{
	font-size: 3rem;
	position: relative;
	padding: 1rem 2rem calc(1rem + 10px);
	background-color:#fffc99;
	margin-left: 1rem !important;
	text-align: center;
}
h1:before {
	position: absolute;
	top: -1rem;
	left: -1rem;
	width: 100%;
	height: 100%;
	content: '';
	border: 4px dotted #444;
}
h2,h3{
	font-size: 2rem;
}
h2 {
  position: relative;
  overflow: hidden;
  padding: 1.5rem 2rem 1.5rem 130px;
  border-top: 3px solid #000;
}

h2:before {
  position: absolute;
  top: -150%;
  left: -74px;
  width: 200px;
  height: 300%;
  content: '';
  -webkit-transform: rotate(25deg);
  transform: rotate(25deg);
  background: #000;
}
h2 span {
  font-size: 40px;
  font-size: 4rem;
  position: absolute;
  z-index: 1;
  top: 0;
  left: 0;
  display: block;
  padding-top: 3px;
  padding-left: 16px;
  color: #fff;
}
html *{
	margin:0;
}
section{
	display:flex;
	flex-direction: column;
}
main{
	max-width: 800px;
	margin: 0 auto;
}
p{
	line-height: 2rem;
}
ul{
	line-height: 1.8rem;
	padding-left: 2rem;
}
fieldset{
	padding:1rem 1.3rem;
}
input{
	height: 30px;
	display: block;
	width: 100%;
}
input[type="button"]{
	font-size: 2rem;
	padding: 0 2rem;
	height: 100%;
	color: #fff;
	background: #116152;
	border: none;
	border-radius: 8px;
	transition: all 0.15s linear;
	margin: 0 auto;
	display: block;
	white-space: wrap;
	line-height: 130%;
	min-height: 50px;
}
input[type="button"]:hover{
	transition: all 0.15s linear;
	background:#053129;
	cursor:pointer;
}
input[type="radio"]{
	width: 16px;
	height: 16px;
	display: inline-block;
}
.caution {
  background: repeating-linear-gradient(135deg, #fff000d4, #fff000d4 10px, #262626c4 10px, #262626c4 20px);
  padding: 6px;
  display: inline-block;
  border: 2px solid #5f5f5f;
  border-radius: 4px;
  box-shadow: 0px 0px 6px 0px #ac2e2ed4;
}
.caution .caution-inner {
  background: #f7f7f7;
  padding: 3rem 2rem 3rem 1rem;
  border: 1px solid #262626c4;
  min-width: 160px;
}
#sample{
	min-height: 266px;
}
#sample textarea{
	width:100%;
	height:333px;
}
#kyakuhon,#result-macros{
	width: 100%;
	height:400px;
}
.mb3{
	margin-bottom:3rem;
}
.mt3{
	margin-top: 3rem;
}
.mb5{
	margin-bottom:5rem;
}
.mt5{
	margin-top: 5rem;
}
.mb8{
	margin-bottom: 8rem;
}
.mt8{
	margin-top: 8rem;
}
footer{
	width:100%;
}
.copyright{
	text-align: center;
	margin:2rem 0;
}
.note{
	color:#c21e09;
}
/*schedule*/
.flex-schedule {
  max-width: 400px;
  list-style: none;
  margin: 0 2rem 0 2em;
  padding-left: 20px;
  border-left: 6px solid #ff5400;
  box-sizing: border-box;
}
.flex-schedule-disabled{
  max-width: 400px;
  list-style: none;
  margin: 0 2rem 0 2em;
  padding-left: 20px;
  border-left: 6px solid #d4d4d4;
  box-sizing: border-box;
}

.flex-schedule li,
.flex-schedule-disabled li{
  width: 100%;
  margin: 0 0;
  padding: 5px 0;
  position: relative;
}

.flex-schedule li::before{
	content: "";
  position: absolute;
  left: -33px;
  top: 24px;
  background: #ff5400;
  width: 20px;
  height: 20px;
  border-radius: 10px;
}
.flex-schedule-disabled li::before {
	content: "";
  position: absolute;
  left: -33px;
  top: 24px;
  background: #d4d4d4;
  width: 20px;
  height: 20px;
  border-radius: 10px;
}

.flex-schedule .sch_box,
.flex-schedule-disabled .sch_box{
  display: inline-block;
  width: 100%;
  margin-left: 30px;
  padding: 15px 10px 15px 10px;
  vertical-align: middle;
  background: #e9e9e9;
  box-sizing: border-box;
  border-radius: 6px;
}

.flex-schedule .sch_title,
.flex-schedule-disabled .sch_title{
  font-size: 16px;
  font-weight: 700;
}
.flex-schedule .sch_tx,
.flex-schedule-disabled .sch_tx {
  font-size: 14px;
  font-weight: normal;
}
span.term{
	font-size: 90%;
	font-weight: bold;
	color: #ce0e0e;
	display: block;
}
/*ここまで*/

/* + button */
.c-markup_view {
display: inline-block;
  font-size: 40px;
}
.dli-plus-circle {
  display: inline-block;
  vertical-align: middle;
  color: #333;
  line-height: 1;
  position: relative;
  width: .8em;
  height: .8em;
  border: 0.1em solid currentColor;
  border-radius: 50%;
  box-sizing: content-box;
  cursor:pointer;
}

.dli-plus-circle > span {
  width: 46%;
  height: 0.1em;
  background: currentColor;
  border-radius: 0.1em;
  position: relative;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  margin: auto;
}

.dli-plus-circle > span::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: inherit;
  border-radius: inherit;
  transform: rotate(90deg);
}
.add_chara{
	text-align: center;
}
/* ここまで */

/*吹き出し*/
.balloon1 {
  position: relative;
  display: inline-block;
  padding: 7px 10px;
  min-width: 120px;
  max-width: 100%;
  color: #555;
  font-size: 16px;
  background: #c8d8ed;
  border-radius: 15px;
  bottom: 5px;
  left: 12px;
}

.balloon1::before {
  content: "";
  position: absolute;
  top: 50%;
  left: -20px;
  margin-top: -7px;
  border: 7px solid transparent;
	border-right-width: 7px;
	border-right-style: solid;
	border-right-color: transparent;
  border-right: 15px solid #c8d8ed;
}
.balloon1 p {
  margin: 0;
  padding: 0;
}
/* ここまで */

#sample figcaption {
  position: relative;
  padding: 1.5rem 2rem;
  color: #fff;
  border-radius: 10px;
  background: #094;
  display: inline-block;
  margin-bottom: 1rem;
  font-weight: bold;
}
#sample figcaption:after {
  position: absolute;
  bottom: -9px;
  left: 1em;
  width: 0;
  height: 0;
  content: '';
  border-width: 10px 10px 0 10px;
  border-style: solid;
  border-color: #094 transparent transparent transparent;
}
.hidden{
	display:none;
}
@media(min-width:700px){
	main{
		padding:3rem;
	}
}
@media(max-width:700px){
	html,textarea {
		font-size:13px;
	}
	main{
		margin:0 1rem;
	}
	h2 span {
		font-size: 3rem;
	}
	h2::before {
		left:-110px;
	}
	h2{
		padding: .8rem 2rem 1.5rem 100px;
		font-size: 1.6rem;
	}
}
ul.annotation {
	list-style:none;
  position: relative;
  margin-left:2rem;
  padding:0;
}
ul.annotation li {
  color: #df0300;
  font-size: 85%;
}
ul.annotation > li::before {
  content: "\203B";
  position: absolute;
  left: -17px;
}
#macro_count{
	list-style: none;
}
#macro_per_character{
	text-align: center;
	position: fixed;
	bottom: 0;
	background: #fff;
	padding: 1rem;
	box-shadow: 2px -4px 8px 3px #0000002b;
	border-radius: 10px 10px 0 0;
	z-index: 100;
	animation: slidein 0.8s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
}
@keyframes slidein{
	from {
	  transform: translateY(120px);
	  opacity: 0;
	}
	to {
	  transform: translateY(0);
	  opacity: 1;
	}
}
#macro_per_character ul{
	padding:0;
}
#macro_per_character h3{
	font-size:1rem;
	color: #fff;
	padding: .2rem .8rem;
	background: #de1720;
	display: inline-block;
	border-radius: 8px;
}
.chidden{
	display: none;
}
.flex-schedule-disabled p.sch_title{
color: #7f7f7f;
}
.flex-schedule .sch_box.orng{
	background:rgb(255, 215, 204);
}
a.btn-flat {
  overflow: hidden;
  padding: 1.5rem 6rem;
  color: #fff;
  border-radius: 0;
  background: #000;
}

a.btn-flat span {
  position: relative;
}

a.btn-flat:before {
  position: absolute;
  top: 0;
  left: 0;
  width: 100px;
  height: 100px;
  content: '';
  -webkit-transition: all .5s ease-in-out;
  transition: all .5s ease-in-out;
  -webkit-transform: translateX(-80%) translateY(-25px);
  transform: translateX(-80%) translateY(-25px);
  border-radius: 50%;
  background: #72deff;
}

a.btn-flat:hover:before {
  width: 400px;
  height: 400px;
  -webkit-transform: translateX(-1%) translateY(-175px);
  transform: translateX(-1%) translateY(-175px);
}
#gnavi ul{
	list-style: none;
}
#gnavi ul li a span{
	color: #fff;
	-webkit-transition: all 0.7s;
	transition: all 0.7s;
}
.btn,
a.btn,
button.btn {
  font-size: 1.2rem;
  font-weight: 700;
  line-height: 1.5;
  position: relative;
  display: inline-block;
  padding: 1rem 4rem;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  -webkit-transition: all 0.3s;
  transition: all 0.3s;
  text-align: center;
  vertical-align: middle;
  text-decoration: none;
  letter-spacing: 0.1em;
  color: #212529;
  border-radius: 0.5rem;
}

 #gnavi ul li a.btn:hover span{
	color:#161616;
	-webkit-transition: all 0.7s;
	transition: all 0.7s;  
}
</style>
<h1 class="mb5 mt5">マクロ化ツール</h1>
<header id="site-header" class="mb5">
	</div>
	<nav id="gnavi">
		<ul>
			<li>
				<a href="separate.html" class="btn btn-flat">
				<span>キャラ別に分ける ></span>
				</a>
			</li>
		</ul>
	</nav>
</header>

<main id="home" class="mb8">
	<h2 class="mb3"><span>01</span>はじめに</h2>
	<p class="mb3">このページでは、完成した脚本を「エモートの入力」前までマクロ化していきます。</p>

	<ul class="flex-schedule-disabled">
		<li>
			<div class="area">
			<div class="sch_box">
				<p class="sch_title">脚本完成</p>
			</div>
			</div>
		</li>
	  </ul>

	<ul class="flex-schedule">
		<!-- <li>
		  <div class="area">
			<div class="sch_box">
			  <p class="sch_title">タイトル</p>
			  <p class="sch_tx">
				内容テキストテキストテキストテキストテキストテキストテ<br>キスト
			  </p>
			</div>
		  </div>
		</li> -->
		<li>
			<div class="area">
			  <div class="sch_box orng">
				<!--<span class="term">※ここから</span>--><p class="sch_title">マクロ番号(連番)を振る</p>
			  </div>
			</div>
		  </li>
		<li>
		  <div class="area">
			<div class="sch_box orng">
			  <p class="sch_title">マクロタイトル(セリフの出だし)を入力</p>
			</div>
		  </div>
		</li>
		<li>
		  <div class="area">
			<div class="sch_box orng">
			  <p class="sch_title">/y や /cwl の入力</p>
			</div>
		  </div>
		</li>
		<li>
		  <div class="area">
			<div class="sch_box orng">
			  <p class="sch_title">&lt;wait.N&gt;の入力</p><!--<span class="term">※ここまで</span>-->
			</div>
		  </div>
		</li>
	  </ul>

	  <ul class="flex-schedule-disabled">
		<li>
			<div class="area">
			<div class="sch_box">
				<p class="sch_title">エモートの入力</p>
			</div>
			</div>
		</li>
		<li>
			<div class="area">
			<div class="sch_box">
				<p class="sch_title">マクロをキャラ別に分ける</p>
			</div>
			</div>
		</li>
	  </ul>

	<p class="mb5 mt5">完成した脚本が↓の「脚本サンプル」のような形式になっているかを、必ずご確認ください。</p>
	<figure id="sample" class="mb3">
		<figcaption>脚本サンプル</figcaption>
		<textarea name="textarea">
※■■■■■　第1章　■■■■■
♪音響【日溜り】
◇1
ルドラ：・・・はぁ～～。。
　　　：暇だ・・・。
　　　：今日はお客さん来ねえなあ～・・・
ヒカリ：おぃーーす、やってるぅ？
ルドラ：ぁ、いらっしゃいませ～...お！
　　　：なんだ、ヒカリじゃん。
ヒカリ：おう、ルドラ。久しぶり！
※■■■■■　第2章　■■■■■
♪音響【無常の喜び】
※※ヒカリ、舞台中央の椅子に座る
◇2
ルドラ：久々だなあ～～。
　　　：まあ、座ってくれよ！
　　　：・・・ラッシーでも飲むか？
ヒカリ：いや、いらねえわ。</textarea>
	</figure>
	<h3>もう一度、脚本をご確認ください</h3>
	<div class="caution mb8">
		<div class="caution-inner">
			<div class="intro-text">
					<ul>
						<li class="note"><strong>章節は「◇N」形式で記述。Nは数字1字を表す。</strong>(「◇1」は1章を意味する。)</li>
						<li>妖精さんパートを作成する時は、OPなら先頭行を「◇0」とし、EDなら「◇劇の終章+1」とする。</li>
						<li>BGMは文頭に「♪」を必ず含ませ、「♪BGM」の形式にする。</li>
						<li>指示書きは文頭に「※」を必ず含ませ、「※指示書き」の形式にする。</li>
						<li><strong>先頭の「※」を文字として残したい場合は、「※※」と書く。</strong></li>
						<li>「指示書き」とは？ → 暗転or明転指示や、「ヒトシ、下手から登場」、ミラプリ変更、等。</li>
						<li>キャラ名が明かされる前の？？？は、この段階ではキャラ名を入力し、完成した後に手動で修正する。</li>
					</ul>
			</div>
		</div>
	</div>
	
	<h2 class="mb3"><span>02</span>キャラ名と脚本を入力します</h2>

	<fieldset>
		<legend>脚本番号の桁数</legend>
		<div>
			<input type="radio" id="three-digit" name="digit" value="3" checked />
			<label for="three-digit">3桁 <span></span></label>
		</div>
		<div>
			<input type="radio" id="four-digit" name="digit" value="4" />
			<label for="four-digit">4桁 <span></span></label>
		</div>
	</fieldset>

	<ul class="annotation mb5">
		<li>「3桁」の場合、1章のマクロ番号を「100」から始め、101,102,103...</li>
		<li>「4桁」の場合、1章のマクロ番号を「1000」から始め、1001,1002,1003...</li>
	</ul>

	<fieldset class="mb5">
		<legend>登場人物名の入力</legend>
		<div class="mb3">
			<label for="chara01">登場人物 1</label>
			<input size="6" maxlength="4" aria-invalid="false" placeholder="キャラ名を入力します(3文字以内)" type="text" name="chara01" id="chara01" class="character-name">
		</div>

		<div class="second_chara">
			<div class="mb3">
				<label for="chara02">登場人物 2</label>
				<input size="6" maxlength="4" aria-invalid="false" placeholder="キャラ名を入力します(3文字以内)" type="text" name="chara02" id="chara02" class="character-name">
			</div>
			<div class="add_chara mb3">
				<div class="c-markup_view">
					<span class="dli-plus-circle"><span></span></span>
				</div>
				<div class="balloon1">
					<p>3人目の登場人物を追加</p>
				</div>
			</div>
		</div>

		<div class="third_chara hidden">
			<div class="mb3">
				<label for="chara02">登場人物 3</label>
				<input size="6" maxlength="4" aria-invalid="false" placeholder="キャラ名を入力します(3文字以内)" type="text" name="chara03" id="chara03" class="character-name">
			</div>
		
			<div class="add_chara mb3">
				<div class="c-markup_view">
					<span class="dli-plus-circle"><span></span></span>
				</div>
				<div class="balloon1">
					<p>4人目の登場人物を追加</p>
				</div>
			</div>
		</div>

		<div class="fourth_chara hidden">
			<div class="mb3">
				<label for="chara02">登場人物 4</label>
				<input size="6" maxlength="4" aria-invalid="false" placeholder="キャラ名を入力します(3文字以内)" type="text" name="chara04" id="chara04" class="character-name">
			</div>
		
			<div class="add_chara mb3">
				<div class="c-markup_view">
					<span class="dli-plus-circle"><span></span></span>
				</div>
				<div class="balloon1">
					<p>5人目の登場人物を追加</p>
				</div>
			</div>
		</div>

		<div class="fifth_chara hidden">
			<div class="mb3">
				<label for="chara02">登場人物 5</label>
				<input size="6" maxlength="4" aria-invalid="false" placeholder="キャラ名を入力します(3文字以内)" type="text" name="chara05" id="chara05" class="character-name">
			</div>
		
			<div class="add_chara mb3">
				<div class="c-markup_view">
					<span class="dli-plus-circle"><span></span></span>
				</div>
				<div class="balloon1">
					<p>6人目の登場人物を追加</p>
				</div>
			</div>
		</div>
		<div class="sixth_chara hidden">
			<div class="mb3">
				<label for="chara02">登場人物 6</label>
				<input size="6" maxlength="4" aria-invalid="false" placeholder="キャラ名を入力します(3文字以内)" type="text" name="chara06" id="chara06" class="character-name">
			</div>
		</div>
	</fieldset>

	<section id="input-kyakuhon" class="mb5">
		<figure>
			<figcaption>脚本を貼り付ける↓</figcaption>
			<!--<ul class="annotation">
				<li>サンプルとして、サベネアの理髪師の「妖精さんパート(OP)」が入力されています。</li>
			</ul>-->
			<textarea name="textarea" placeholder="ここに脚本を貼り付けます..." id="kyakuhon"></textarea>
		</figure>
	</section>
	<input type="button" value="マクロ化を実行"  id="run">

	<h2 class="mb5 mt8"><span>03</span>完成したマクロをコピーします</h2>
	<section id="result" class="mb8">
		<figure class="mb5">
			<figcaption>完成マクロ</figcaption>
			<textarea name="textarea" id="result-macros"></textarea>
		</figure>
		<p class="note"></p>
		<input type="button" value="マクロをコピー" id="copy">
	</section>

	<h2 class="mb3 mt8"><span>04</span>この後の工程について</h2>
	<section id="result" class="mb8">
		<ol class="mb3">
			<li>役者さんにエモート入力をお任せする</li>
			<li>脚本家自身がエモートを入力する</li>
		</ol>
		
		<p>1.の場合は、<a href="separate.html"><strong>「マクロをキャラ別に分ける」</strong></a>に進んでください。</p>
		<p>2.の場合は、次項、「05.txtファイルを作成して貼り付ける」に進んでください。</p>
	</section>

	<h2 class="mb3 mt8"><span>05</span>txtファイルを作成して貼り付ける</h2>
	<section id="result" class="mb8">
		<p>ご自身のスマホやPCで、txtファイルを新しく作成し、コピーしたマクロを貼り付けて保存します。</p>
		<p class="mb3">完成マクロでは、wait.Nの待ち時間は、セリフ一行の文字数によって自動選択されています。</p>
		<ul class="mb3">
			<li>～4文字なら &lt;wait.2&gt;</li>
			<li>5～15文字なら &lt;wait.3&gt;</li>
			<li>15～25文字なら &lt;wait.4&gt;</li>
			<li>25字以上で &lt;wait.5&gt;</li>
		</ul>
		<p>作者は、自動選択された&lt;wait.N&gt;の秒数が、ご自身が意図するセリフのタイミングとなるよう、手動で修正してください。</p>
		<p>また、この秒数ですが、比較的簡単に修正ができますので、ぜひフィードバックをお寄せくださいませ！</p>
	</section>

	<div id="macro_per_character" class="chidden">
		<h3>キャラ別マクロ数</h3>
		<ul id="macro_count"></ul>
	</div>
</main>

<footer style="margin-top:16rem;">
	<div class="copyright">© 2024 劇団彩</div>
</footer>

<script>
	/* 登場人物追加ボタン */
	let addbtn = document.querySelectorAll(".c-markup_view");
	addbtn.forEach(e => {
		e.addEventListener('click', () => {
			e.parentElement.classList.add("hidden");	//クリックした+ボタンを消す
			let element = e.parentElement.parentElement.nextElementSibling;
			//console.log("elementの値は：%o",element);
			element.classList.remove("hidden");		 //次の入力欄を表示する
		})
	})

	/* マクロ化 */
	let run = document.getElementById("run");
	run.addEventListener("click", function(e){

		//(入力文字数の判定)txtareaから入力した脚本の文字列の文字数を取得
		let kyakuhon_str = document.getElementById('kyakuhon').value;

		if(kyakuhon_str.length > 20){ //貼り付けられた脚本テキストが21字以上の時のみマクロ化を実行(ゆるめに設定)

			let flag_seven_lines_checker = 1;
			if( kyakuhon_str.match(/\/converse/g) ){
				flag_seven_lines_checker = 0;
			}
			// console.log("flag_seven_lines_checkerの値は：",flag_seven_lines_checker);
			const input = document.getElementById('kyakuhon');			 //脚本を貼り付けるtextarea
			const output = document.getElementById('result-macros');	 //マクロ化後の完成テキストを表示するtextarea
			let result = input.value;									//貼り付けられた脚本を、プログラム中で使用するための変数

			//データクレンジング
				// 空白の改行が含まれていた場合、削除
				result = result.replace(/\n\n\n\n/gm,"\n")
				.replace(/\n\n\n/gm,"\n")
				.replace(/\n\n/gm,"\n");

				//行末にスペースがあった場合、削除
				result = result.replace(/^(.*)( |　)$/gm,"$1")
				.replace(/^(.*)( |　)$/gm,"$1")
				.replace(/^(.*)( |　)$/gm,"$1")
				.replace(/^(.*)( |　)$/gm,"$1")
				.replace(/^(.*)( |　)$/gm,"$1");

				//なんかたくさんの半角でスペースあけていた場合
				result = result.replace(/^   +：$/gm,"　　　：");

				//なんか違う♢←だった場合、◇になおす
				result = result.replace("♢","◇");

				// ◇Nの"N"が全角だった場合に半角に置換
					const lines = result.split('\n');   // 行ごとに分割
					const pattern = /^◇([０-９]+)$/;   // 正規表現パターン："◇"の直後に全角数字がある行
					const convertedLines = [];		 // 変換後の文字列を格納する配列

					// 各行を配列で処理
					for (const line of lines) {
						const match = line.match(pattern);
						if (match) {
							// 全角数字を半角数字に変換
							const fullwidthNumber = match[1];
							const halfwidthNumber = fullwidthNumber.replace(/[０-９]/g, (char) => {
								return String.fromCharCode(char.charCodeAt(0) - 0xfee0);
							});
							convertedLines.push(`◇${halfwidthNumber}`);
						} else {
							convertedLines.push(line);
						}
					}
					while (convertedLines.length > 0 && convertedLines[convertedLines.length - 1] === "") {	// 脚本の最後行に改行があった場合、削除。
						convertedLines.pop();
					}
					result = convertedLines.join('\n');   // 変換後の文字列を結合して表示
				// -----------------------------------


				// ：が半角だった場合、全角に置換
				result = result.replace(/:/gm,"：");
				
				// ：が；(全角)だった場合、：に置換
				result = result.replace(/；/gm,"：");

				// ：が;(半角)だった場合、：に置換
				result = result.replace(/;/gm,"：");


				// セリフの2行目以降に全角コロンが含まれない場合、修正してあげる
					const cname_maxstr = document.getElementsByName('cname_maxstr');	// 登場人物の最大文字数のラジオボタンの要素を取得
					// for (let p = 0; p < cname_maxstr.length; p++) {
					// 	if (cname_maxstr.item(p).checked) {
					// 		var charMaxStr = cname_maxstr.item(p).value;	// チェックされたラジオボタンに対応した値を取得
					// 	}
					// }

					// 配列の全要素のうち、最大文字数を返す
					const findMaxStringLength = (strArray) => {
						if (!strArray.length) return 0;
						return Math.max(...strArray.map(str => str.length));
					}
					
					const characterNameInputs = document.querySelectorAll('.character-name');									   // HTMLからinput要素を取得
					const characterNames = Array.from(characterNameInputs).map(input => input.value).filter(item => item !== "");   // input要素が入ったオブジェクトを配列に変換し、空が格納された要素のみ削除
					const charMaxStr = findMaxStringLength(characterNames);
					
					// console.log("characterNameInputs の値は：%o",characterNameInputs);
					// console.log("characterNames の値は：%o",characterNames);
					const fullWidthSpace = "　".repeat(charMaxStr);			// 取得した値の数分だけ、全角スペースを繰り返して代入
					

					const lines4 = result.split('\n');   // 行ごとに分割
					const match2 = new RegExp(`^${fullWidthSpace}.([^：])`);
					const array1 = [];
					for (const line of lines4) {
						const nocolon = line.match(match2);
						if (nocolon){
							const colonreplace = line.replace(new RegExp(match2, "g"), `${fullWidthSpace}：` + "$1");
							array1.push(colonreplace);
						} else {
							array1.push(line);
						}
					}
					result = array1.join('\n');   // 変換後の文字列を結合して表示
				// -----------------------------------

				//キャラ名の前後に空白がある場合、除去
					const cNameInputs = document.querySelectorAll('.character-name'); // HTMLからinput要素を取得
					let cNameArray = [];
					
					cNameInputs.forEach((input) => {
						const inputValue = input.value.trim();
						cNameArray.push(inputValue);
					});
					cNameArray = cNameArray.filter(Boolean);	// 空の要素を削除

// 下のfor文、いらなくね？と思い書いたが、セリフが一部吹き飛んだ。テストするのが面倒なので、元の冗長なコードを生かした。
//				for(let i = 0;i < cNameArray.length; i++){
//					let pattern = new RegExp(`[ 　]+(${cNameArray[i]})[ 　]*|[ 　]*(${cNameArray[i]})[ 　]+`,"gm");
//					result = result.replace(pattern, "$1");
//				}

					for (let t of cNameArray) {
						let array2 = [];
						let lines5 = result.split('\n');   	// 行ごとに分割
						let matchx = "(^[　 ]+)" + t;		//キャラ名の【直前】に1つ以上の半角or全角スペースが存在する場合にマッチ

						let flag;
						if (t.length === 2){			   //キャラ名が2文字の場合
							flag = 2;
						}else if(t.length === 3){		  	//キャラ名が3文字の場合
							flag = 3;
						}

						let matchy;
						if(flag == 2){
							matchy = t + "(?=[　 ]{2,}).*：";  //キャラ名の【直後】に2つ以上の半角or全角スペースが存在する場合にマッチ
						}else if(flag == 3){
							matchy = t + "(?=[　 ]+).*：";  //キャラ名の【直後】に1つ以上の半角or全角スペースが存在する場合にマッチ
						}
						
						for (let line of lines5) { 
							let extraspace_before = line.match(matchx);
							let extraspace_after = line.match(matchy);
							var zz = line;
							if (extraspace_before){
								zz = line.replace(new RegExp(matchx, "gm"), t);
							}
							if(extraspace_after){
								if(flag == 2){
									zz = line.replace(new RegExp(matchy, "gm"), t + "　：");
								}else if(flag == 3){
									zz = line.replace(new RegExp(matchy, "gm"), t + "：");
								}
							}
							array2.push(zz);
						}
						result = array2.join('\n');   // 変換後の文字列を結合して表示
					}

				// -----------------------------------


				//空白が4つ以上続く文字列は、全角3つに置換
				// result = result.replace(/^[ 　]{4,}.*：/gm,"　　　：")
				// .replace(/:/gm,"：");			


				//◇Nの次行に※や♪があった場合、行順序を入れ替える
				//(条件を満たすまでforしたいが、めんどくさいし、下記でも処理速度に影響なしなので、同じ処理をアホほど繰り返すことにした)
				result = result.replace(/^(◇\d$)\n(([※♪]).*$)/gm,"$2" + "\n" + "$1")
				.replace(/^(◇\d$)\n(([※♪]).*$)/gm,"$2" + "\n" + "$1")
				.replace(/^(◇\d$)\n(([※♪]).*$)/gm,"$2" + "\n" + "$1")
				.replace(/^(◇\d$)\n(([※♪]).*$)/gm,"$2" + "\n" + "$1")
				.replace(/^(◇\d$)\n(([※♪]).*$)/gm,"$2" + "\n" + "$1")
				.replace(/^(◇\d$)\n(([※♪]).*$)/gm,"$2" + "\n" + "$1")
				.replace(/^(◇\d$)\n(([※♪]).*$)/gm,"$2" + "\n" + "$1");
				
				
				// test_result(result,"1.データクレンジング後");


			//-------------------------------

			// バリデーション
				//1.空白改行
				const hasDoubleNewlines = /\n\n/m.test(result);
				if(hasDoubleNewlines){alert("空白の改行が脚本に存在します。\n脚本を修正してください。");return;}

				//2."◇"の直後にスペースや改行が来ていないか
				const next = /^◇( |　|\n).*/m.test(result);
				if(next){alert("◇の次に空白や改行が含まれています。\n脚本を修正してください。");return;}

				//3.章節の次行がセリフになっているか
				const instructions = /^◇.*\n※/m.test(result);
				const bgm = /^◇.*\n♪/m.test(result);
				const space = /^◇.*\n( |　)+/m.test(result);
				if(instructions || bgm || space){alert("◇N(章節)の次の行に、指示書きやBGMが書かれています。\n章節の次の行にセリフがくるよう、修正してください。\n◇Nの、次の行の頭にスペースが無いか？についても、確認してください。");return;}

				//4.登場人物名が重複していた場合、アラートを表示し終了
				const nonEmptyCharacterNames = characterNames.filter(name => name.trim() !== '');
				const hasDuplicates = new Set(nonEmptyCharacterNames).size !== nonEmptyCharacterNames.length;
				if (hasDuplicates) {alert('登場人物名が重複しています。');return;}

				//5.登場人物名欄に入力されたキャラ名が存在しなければ、アラートを表示し終了
				let cNameArray2 = [];
				characterNameInputs.forEach((input) => {
					const inputValue = input.value.trim();
					cNameArray2.push(inputValue);
				});
				cNameArray2 = cNameArray2.filter(Boolean);	//配列から空の要素を削除
				let existCharacter = [];
				for (let t of cNameArray2) {
					if(!result.match(t)){
						existCharacter.push(t);
					}
				}
				if(existCharacter.length){ //配列が空ではなかった場合
					let x = existCharacter.join('\n');   // 配列内のキャラ名を、改行区切りでｘに代入
					alert("次のキャラクター名は、マクロ内に存在しません。\n" + x + "\n「登場人物名」を修正してください。");
					return;
				}
				

				// test_result(result,"2.バリデーション後");


			//-------------------------------
			
			
				//登場人物名を取得し配列に格納
				const charaNameArray = []; // 配列にプッシュするための空の配列
				// characterNameInputs.forEach((input) => {
					// const inputValue = input.value.trim();
					// if (inputValue.length === 2){			   //キャラ名が2文字の場合
					//	 charaNameArray.push(`${inputValue}　：`);
					// }else if(inputValue.length === 3){		  //キャラ名が3文字の場合
					//	 charaNameArray.push(`${inputValue}：`);
					// }
				// });
				for(let i = 0; i < characterNames.length; i++){
					const inputValue = characterNames[i].trim();	// characterNamesにはinputに入力された順に登場人物の名前が入っている。もし前後に空白があれば削除する。
					charaNameArray.push(`${inputValue}：`);		 	// 配列にプッシュ
				}
				// console.log("charaNameArrayの値は：%o",charaNameArray);
				
				if(charaNameArray == ""){alert("登場人物名を正しく入力してください。");return;} //登場人物名が入力されていなかったり、1文字だった場合に処理を抜ける。

				//「人物名：」の行頭に改行を挿入し、ついでにキャラ別のマクロ数をカウントする
				let macro_couter = [];
				for (const t of charaNameArray) {
					result = result.replace(new RegExp(t, "g"), `\n${t}`);  //改行を挿入
					const matchCount = (result.match(new RegExp(t, "gm")) || []).length;
					macro_couter.push(matchCount);
				}

				// test_result(macro_couter,"macro_couter");

				//ラジオボタンから「3桁」or「4桁」の情報を整数で取得
				let elements = document.getElementsByName('digit');
				let len = elements.length;
				let checkValue = '';
				for (let p = 0; p < len; p++) {
					if (elements.item(p).checked) {
						checkValue = elements.item(p).value;
					}
				}

				//◇の次の数字を取得しつつ、空白の改行にマクロ連番を振る
				const lines2 = result.split('\n');  // 行ごとに分割
				const maximumLine = lines2.length   // 行数
				const pattern2 = /^◇(\d)$/gm;	  // 正規表現パターン："◇"の直後に数字がある行
				const pattern3 = /^$/gm;			// 空白の改行
				const convertedLines2 = [];		 // 変換後の文字列を格納する配列

				// test_result(result,"result");

				let u;
				for (let i = 0; i < maximumLine; i++) {
					if (lines2[i].match(pattern2)) {
						u = 0;
						if(checkValue == 3){
							u = Number(lines2[i].charAt(1)) * 100
						}else if(checkValue == 4){
							u = Number(lines2[i].charAt(1)) * 1000
						}
					}else if(lines2[i].match(pattern3)){
						if(u == undefined){
							u = 0;
						}
						if(u < 100){  //10～99の場合、前ゼロで埋める
							if(checkValue == 3){
								u = u.toString().padStart(3, '0');
							}else if(checkValue == 4){
								u = u.toString().padStart(4, '0');
							}
						}
						let z = lines2[i+1].slice(0,8);	 	//次のセリフを先頭から8文字取得
						convertedLines2.push(u + " " + z);  //連番を振る
						u++;
					} else {
						convertedLines2.push(lines2[i]);
					}
				}
				result = convertedLines2.join('\n');   // 変換後の文字列を結合して表示


				// test_result(result,"3.データフォーマット、カウント完了・マクロ化前");



				//上記までで、フォーマットされたとみなし、いよいよマクロに加工していく
				result = result.replace(/^(\d{3,4})/gm,"\n" + "$1")			 	//マクロ番号の直前に改行を挿入
				.replace(/(\n)\n(\d{3,4}.*$)/gm,"$1"+"/cwl "+"$2"+"\n"+"$2");	//セリフ最終行に、次のセリフを挿入
				
				for (const t of charaNameArray) {							   //「人物名：」の前に/yを挿入
					result = result.replace(new RegExp("^" + t, "gm"), `/y ${t}`);
				}

				result = result.replace(new RegExp(`^(${fullWidthSpace}：)`,"gm"),"/y " + "$1")		 //セリフ2行目以降にも行頭に/yを挿入
				.replace(/^(\d{3,4}.*$)/gm,"\n\n"+"$1")												//マクロ番号の直前に改行を挿入
				.replace(/^♪/gm,"/cwl ♪")
				.replace(/^[※]/gm,"/cwl ")
				.replace(/(^\/cwl.*(?<!<wait\.[\d]>)$)(?!\n\n)/gm,"$1" + " <wait\.1>");			  //セリフ最終行の次のセリフ以外の/cwlの末尾に<wait.1>を挿入

				//一行ずつ走査し、/yセリフ行の場合、文字数をカウントして<wait.N>を挿入
				const lines3 = result.split('\n');  					// 行ごとに分割
				const maximumLine2 = lines3.length  					// 行数
				const pattern4 = /^(\/y .*(?<!<wait\.[\d]>)$)/gm;	  	// 正規表現パターン：行頭が/y で始まる行
				const convertedLines3 = [];		  						// 変換後の文字列を格納する配列

				for (let i = 0; i < maximumLine2; i++) {
					if (lines3[i].match(pattern4)) {
						let length = lines3[i].length;
						var push_wait;
						if(length < 12){						//「/y ルドラ：」までが7文字
							push_wait = lines3[i] + " <wait.2>";		// ～4文字なら <wait.2>
						}
						else if(length >= 12 && length < 21){   // 5～13文字なら <wait.3>
							push_wait = lines3[i] + " <wait.3>";
						}
						else if(length >= 21 && length < 38){   // 14～30文字なら <wait.4>
							push_wait = lines3[i] + " <wait.4>";
						}
						else if(length >= 38){				  	// 31字以上で <wait.5>
							push_wait = lines3[i] + " <wait.5>";
						}
						convertedLines3.push(push_wait);
					} else {
						convertedLines3.push(lines3[i]);
					}
				}
				result = convertedLines3.join('\n');   // 変換後の文字列を結合して表示

				result = result
				.replace(/^(\/y|\/sh|\/say)( .*)(<wait\.[\d]>)(\n\/[a-z]+)(?<! <wait\.[\d]>)$/gm,"$1" + "$2" + "$4" + " $3")	// セリフ行の次行にエモがあり、エモの末尾にwaitが無い場合、セリフ行のwaitをエモ行の末尾へ移動
				.replace(/^(\/(y|sh|say) .*<wait\.[\d]>\n\/(?!(y|sh|say) ).*) <wait\.[\d]>/gm,"$1")								// セリフ行の末尾と、次行のエモの末尾にwaitがある場合、除去
				.replace(/^(\/y|\/sh|\/say)( .*)(<wait\.[\d]>)(\n\/[a-z]+)(?<! <wait\.[\d]>)$/gm,"$1" + "$2" + "$4" + " $3")	// 【同じ処理】セリフ行の次行にエモがあり、エモの末尾にwaitが無い場合、セリフ行のwaitをエモ行の末尾へ移動
				.replace(/^(\/[a-z]+ .*<wait\.)\d(>$\n\/cwl)/gm,"$1" + "1" + "$2")			  									// /y行のうち、次行が/cwlのものだけwaitを1に変更
				.replace(/^(.*)<wait\.1>$(?!(\n))/gm,"$1" + "\n\n");															// 最終行に改行を2行入れる

				// console.log("resultの値は：%o",result);
				// console.log(typeof `resultの型は：${result}`);

				// 7行チェッカー
				// 1つのマクロ欄へ登録できる行数は15行。1行のセリフに対し1エモを想定すると、1マクロあたりの最大セリフ行数は7行となる。
				if(cNameInputs[0].value !== "わらし")	{				// わらしちゃんパートも同様
					if(flag_seven_lines_checker){				// 貼り付けた脚本に /converse が含まれていたら、エモ入りの脚本とみなし、チェッカーを動作させない。
						let sections = result.split('\n\n');	// 文字列を\n\nで分割
						for (let section of sections) {		 	// 各セクションの行数を確認
							let lines = section.split('\n');
							if (lines.length > 10) {
								alert("行数が7行を超えている箇所があります。\n後にエモートを入力するので、7行以内に収めるか、マクロを分割してください。");
								return;
							}
						}
					}
				}

			
			output.value = result;					//完成マクロのtextareaに反映
			alert("マクロが出力されました。\nご確認ください。");

			//キャラ別マクロ数の表示
			const divElement = document.getElementById('macro_count');
			const macro_per_character = document.getElementById('macro_per_character');
			divElement.innerHTML = '';  // innerHTMLを空にする
			macro_per_character.classList.remove('chidden');	//chiddenを除去
			for(i=0; i < charaNameArray.length; i++){   //charaNameArrayには、「タカシ：」や「リサ　：」が入っている。
				const liElement = document.createElement('li');
				liElement.textContent = charaNameArray[i] + macro_couter[i] + " 個";
				divElement.appendChild(liElement);
			}

		}else{
			alert("脚本の文字数が少ないようです。\nもう一度、お手元の脚本を貼り付けてください。");
		}
	});

	/*コピーボタンをクリックしたときにテキストをクリップボードにコピー*/
	const copyButton = document.getElementById("copy");
	copyButton.addEventListener("click", (e) => {
		const textarea = document.getElementById("result-macros");
		textarea.select();			  // テキストを選択
		document.execCommand("copy");   // クリップボードにコピー
		alert("マクロをコピーしました。");
	});

	const test_result = (result,num) =>{
		console.log(`■ ${num}：`);
		console.log("-----------------------------------");
		console.log("resultの値は：%o",result);
		console.log(typeof `resultの型は：${result}`);
		console.log("-----------------------------------\n\n");
	}

</script>
</html>
